esphome:
  name: ${devicename}
  comment: ${devicecomment}
  on_boot:
    priority: 250.0
    then:
      lambda: |-
        id(github).publish_state("");
        id(again_on_counter).publish_state( std::to_string(id(my__increase_off_counter)).c_str());

        if (id(door).state) {
          id(status_change)->execute(1);
        }else{
          id(my__counter) = 0;
        }

esp8266:
  board: ${board}

# Enable logging
logger:

# Enable Home Assistant API
api:
  port: 6053
  encryption:
    key: ${apikey}
  reboot_timeout: 0s

ota:
  safe_mode: true
  password: ${otakey}
  reboot_timeout: 0s

web_server:
  port: 80

wifi:
  ssid: ${wifi}
  password: ${wifipass}

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${capitalized_name} ${title_ap_ssid}"
    password: "12345678"

#captive_portal:

time:
  - platform: sntp
    id: sntp_time
    timezone: "America/Sao_Paulo"
    servers: ["a.st1.ntp.br", "b.st1.ntp.br", "c.st1.ntp.br"]
    on_time:
      - seconds: 0
        minutes: 0
        hours: 17
        then:
          lambda: |-
            id(my__increase_off_counter) = 0;
            id(again_on_counter).publish_state("0");

      - seconds: 0
        minutes: 0
        hours: 6
        then:
          lambda: |-
            id(my__increase_off_counter) = 0;
            id(again_on_counter).publish_state("0");

interval:
  - interval: 1000ms
    then:
      lambda: |-
        /*
         * counter of timer between off and on
         */

        if (id(my__off_counter) >= 0){
          id(my__off_counter) += 1;

          if (id(my__off_counter) >= id(between_onoff_check).state){
            // it didn't turn back on again: stop counter of timer between off and on
            id(my__off_counter) = -1;
          }
        }

        /*
         * Timer ON counter
         */

        if (id(my__counter) <= 0){
          return;
        }

        /* decreases */
        id(my__counter) -= 1;

        /* IT ENDED? */
        if (id(my__counter) == 0){
          id(relay).turn_off();
          return;
        }

        /* STILL COUNTING? SHOW THE LACK OF TIME */
        // Declare variables for seconds, hours, minutes, and seconds
        unsigned short h, m, s;

        // Calculate hours, minutes, and remaining seconds
        h = (id(my__counter)/3600);
        m = (id(my__counter) -(3600*h))/60;
        s = (id(my__counter) -(3600*h)-(m*60));

        // expected 9 positions, but placed 19 to
        // avoid WARNs in compilation
        char buf[19];
        sprintf(buf, "%02d:%02d:%02d\n",h,m,s);
        id(remainingtime).publish_state(buf);

globals:
  - id: my__counter
    type: int
    restore_value: no
    initial_value: "0"

  - id: my__off_counter
    type: int
    restore_value: no
    initial_value: "-1"

  - id: my__increase_off_counter
    type: int
    initial_value: "0"
    restore_value: true

button:
  - platform: restart
    name: ${title_restart}
    icon: "mdi:icon7-off"

  - platform: template
    name: ${title_reset_onoff_counter}
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        lambda: |-
          id(my__increase_off_counter) = 0;
          id(again_on_counter).publish_state("0");

  - platform: template
    name: ${title_manual_open}
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        - lambda: id(status_change)->execute(1);

  - platform: template
    name: ${title_manual_close}
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        - lambda: id(status_change)->execute(0);

number:
  - platform: template
    id: minseconds
    name: ${title_turn_off_closed}
    icon: "mdi:icon7-time"
    min_value: 10
    max_value: 1800
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: maxseconds
    name: ${title_turn_off_opened}
    icon: "mdi:icon7-time"
    min_value: 30
    max_value: 3600
    step: 1
    initial_value: 1800
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_check
    name: ${title_turn_on_again}
    icon: "mdi:icon7-time"
    min_value: 5
    max_value: 60
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_add
    name: ${title_turn_on_again_add}
    icon: "mdi:icon7-time"
    min_value: 10
    max_value: 60
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_maxadd
    name: ${title_turn_on_again_maxadd}
    min_value: 0.1
    max_value: 7
    step: 0.1
    initial_value: 1
    optimistic: true
    restore_value: true

switch:
  - platform: gpio
    name: "${title_light}"
    id: relay
    icon: "mdi:icon7-lightbulb"
    pin:
      number: ${pin_rele}
      inverted: false

    disabled_by_default: false
    restore_mode: RESTORE_DEFAULT_OFF

    on_turn_on:
      lambda: |-
        id(my__counter) = id(maxseconds).state;

        // CHECK and stop counter of timer between off and on
        if (id(my__off_counter) >= 0){
          // increase the number of times it was turned on
          // shortly after being turned off
          id(my__increase_off_counter) += 1;

          id(again_on_counter).publish_state( std::to_string(id(my__increase_off_counter)).c_str());
        }

        id(my__off_counter) = -1;

    on_turn_off:
      lambda: |-
        id(my__counter) = 0;
        id(remainingtime).publish_state("OFF");

        // start counter of timer between off and on
        id(my__off_counter) = 0;

script:
  id: status_change
  parameters:
    x: int
  then:
    lambda: |-
      // is open
      if (x){
        id(my__counter) = id(maxseconds).state;
        id(relay).turn_on();

      // is cloused
      }else{
        int increase = abs(
          id(between_onoff_add).state *

          // increase seconds to OFF state
          (id(my__increase_off_counter) > 1 ? id(my__increase_off_counter) - 1 : 0 )
        );

        int max_addseconds  = abs( ((1.0+(float)id(between_onoff_maxadd).state)) * ((float)id(minseconds).state) );

        ESP_LOGI("main", "Contador incremental limitado a '%d' segundo(s).", max_addseconds);

        id(my__counter) = id(minseconds).state + increase;

        if (id(my__counter) > max_addseconds){
          id(my__counter) = max_addseconds;
        }

        if (id(my__counter) > id(maxseconds).state){
          id(my__counter) = id(maxseconds).state;
        }

        ESP_LOGI("main", "Iniciando timer em '%d' segundos.", id(my__counter));
      }

binary_sensor:
  - platform: gpio
    pin:
      number: ${pin_sensor}
      mode:
        input: true
        pulldown: true
    name: ${title_dooropened}
    id: door
    filters:
      - delayed_on_off: 200ms
    on_state:
      - lambda: id(status_change)->execute(x);

  - platform: gpio
    pin:
      number: ${pin_button}
      mode:
        input: true
        pullup: true
    name: "Push Buttom"
    filters:
      - delayed_on_off: 200ms
    on_state:
      lambda: |-
        if (!x){
          id(relay).toggle();
        }

text_sensor:
  - platform: template
    id: remainingtime
    icon: "mdi:icon7-clock-fill"
    name: ${title_off_in}
  #    update_interval: 1s

  - platform: template
    id: again_on_counter
    name: ${title_again_on_counter}
    icon: "mdi:icon7-calculator"
  #    update_interval: 60s

  - platform: template
    name: "Github"
    icon: "mdi:icon-github"
    id: github
    filters:
      lambda: return {"JeanCarloEM/esphome_timed_door_light"};

  - platform: version
    name: "ESPHome Version"
