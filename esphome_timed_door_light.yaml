esphome:
  name: ${devicename}
  comment: ${devicecomment}
  on_boot:
    priority: 250.0
    then:
      lambda: |-
        id(again_on_counter).publish_state( std::to_string(id(my__increase_off_counter)).c_str());

        if (id(door).state) {
          id(status_change)->execute(1);
        }else{
          id(my__counter) = 0;
        }

esp8266:
  board: ${board}

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: ${apikey}
  reboot_timeout: 0s

ota:
  safe_mode: true
  password: ${otakey}
  reboot_timeout: 0s

web_server:
  port: 80

wifi:
  ssid: ${wifi}
  password: ${wifipass}

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${capitalized_name} ${title_ap_ssid}"
    password: "12345678"

#captive_portal:

sun:
  latitude: ${default_latitude}
  longitude: ${default_longitude}
  id: sun_sun

time:
  - platform: homeassistant
    id: ha_time

  - platform: sntp
    id: sntp_time
    timezone: ${default_timezone}
    servers: ["time.cloudflare.com", "time.google.com", "0.pool.ntp.org"]

    on_time:
      - seconds: 0
        minutes: 0
        hours: 17
        then:
          lambda: |-
            id(my__increase_off_counter) = 0;
            id(again_on_counter).publish_state("0");

      - seconds: 0
        minutes: 0
        hours: 6
        then:
          lambda: |-
            id(my__increase_off_counter) = 0;
            id(again_on_counter).publish_state("0");

interval:
  - interval: 1000ms
    then:
      lambda: |-
        /*
         * counter of timer between off and on
         */

        if (id(my__off_counter) >= 0){
          id(my__off_counter) += 1;

          if (id(my__off_counter) >= id(between_onoff_check).state){
            // it didn't turn back on again: stop counter of timer between off and on
            id(my__off_counter) = -1;
          }
        }

        /*
         * Timer ON counter
         */

        if (id(my__counter) <= 0){
          return;
        }

        /* decreases */
        id(my__counter) -= 1;

        /* IT ENDED? */
        if (id(my__counter) == 0){
          id(relay).turn_off();
          return;
        }

        /* STILL COUNTING? SHOW THE LACK OF TIME */
        // Declare variables for seconds, hours, minutes, and seconds
        unsigned short h, m, s;

        // Calculate hours, minutes, and remaining seconds
        h = (id(my__counter)/3600);
        m = (id(my__counter) -(3600*h))/60;
        s = (id(my__counter) -(3600*h)-(m*60));

        // expected 9 positions, but placed 19 to
        // avoid WARNs in compilation
        char buf[19];
        sprintf(buf, "%02d:%02d:%02d\n",h,m,s);
        id(remainingtime).publish_state(buf);

globals:
  - id: my__counter
    type: int
    restore_value: no
    initial_value: "0"

  - id: my__off_counter
    type: int
    restore_value: no
    initial_value: "-1"

  - id: my__increase_off_counter
    type: int
    initial_value: "0"
    restore_value: true

button:
  - platform: restart
    name: "9W. ${title_restart}"
    icon: "mdi:icon7-off"

  - platform: template
    name: "1F. ${title_reset_onoff_counter}"
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        lambda: |-
          id(my__increase_off_counter) = 0;
          id(again_on_counter).publish_state("0");

  - platform: template
    name: "9W. ${title_manual_open}"
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        - lambda: id(status_change)->execute(1);

  - platform: template
    name: "9V. ${title_manual_close}"
    icon: "mdi:icon7-terminal"
    on_press:
      then:
        - lambda: id(status_change)->execute(0);

number:
  - platform: template
    id: minseconds
    name: "2B. ${title_turn_off_closed}"
    icon: "mdi:icon7-time"
    min_value: 10
    max_value: 1800
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: maxseconds
    name: "2A. ${title_turn_off_opened}"
    icon: "mdi:icon7-time"
    min_value: 30
    max_value: 3600
    step: 1
    initial_value: 1800
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_check
    name: "1D. ${title_turn_on_again}"
    icon: "mdi:icon7-time"
    min_value: 5
    max_value: 60
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_add
    name: "3A. ${title_turn_on_again_add}"
    icon: "mdi:icon7-time"
    min_value: 10
    max_value: 60
    step: 1
    initial_value: 30
    optimistic: true
    restore_value: true

  - platform: template
    id: between_onoff_maxadd
    name: "3B. ${title_turn_on_again_maxadd}"
    min_value: 0.1
    max_value: 7
    step: 0.1
    initial_value: 2
    optimistic: true
    restore_value: true

  - platform: template
    name: "4A. ${title_just_light_up_the_night}"
    id: nightonly
    icon: "mdi:icon7-time"
    min_value: 0
    max_value: 120
    step: 1
    initial_value: 0
    optimistic: true
    restore_value: true

  - platform: template
    id: latitude_val
    name: "4B. ${title_latitude}"
    min_value: -90
    max_value: 90
    step: 0.0001
    initial_value: 21.9961
    optimistic: true
    restore_value: true
    icon: "mdi:icon7-globe"
    on_value:
      then:
        - script.execute: sun_position_change

  - platform: template
    id: longitude_val
    name: "4C. ${title_longitude}"
    icon: "mdi:icon7-globe"
    min_value: -90
    max_value: 90
    step: 0.0001
    initial_value: 47.4258
    optimistic: true
    restore_value: true
    on_value:
      then:
        - script.execute: sun_position_change

switch:
  - platform: gpio
    name: "1B. ${title_light}"
    id: relay
    icon: "mdi:icon7-lightbulb"
    pin:
      number: ${pin_rele}
      inverted: false

    disabled_by_default: false
    restore_mode: RESTORE_DEFAULT_OFF

    on_turn_on:
      lambda: |-
        id(my__counter) = id(maxseconds).state;

        // CHECK and stop counter of timer between off and on
        if (id(my__off_counter) >= 0){
          // increase the number of times it was turned on
          // shortly after being turned off
          id(my__increase_off_counter) += 1;

          id(again_on_counter).publish_state( std::to_string(id(my__increase_off_counter)).c_str());
        }

        id(my__off_counter) = -1;

    on_turn_off:
      lambda: |-
        id(my__counter) = 0;
        id(remainingtime).publish_state("OFF");

        // start counter of timer between off and on
        id(my__off_counter) = 0;

script:
  - id: sun_position_change
    then:
      lambda: |-
        return;

  - id: status_change
    parameters:
      x: int
    then:
      if:
        condition:
          not:
            and:
              - lambda: "return x != 0;"
              - lambda: |-
                  if (id(nightonly).state <= 0){
                    return false;
                  }

                  ESPTime nowtime = id(ha_time).now();

                  if (!nowtime.is_valid()){
                    nowtime = id(sntp_time).now();
                  }

                  if (!nowtime.is_valid()){
                    return {"..."};
                  }

                  // get only current hour and minute
                  char buffer[26];
                  struct tm now = nowtime.to_c_tm();
                  strftime(buffer, sizeof(buffer), "%d/%m/%Y, %H:%M", &now);

                  puts(buffer);

                  // convert only current hour and minute TO time value
                  struct tm only_time;
                  strptime(buffer, "%H:%M", &only_time);
                  time_t newnow = mktime(&now);

                  return (
                    // a partir de minutos antes do por do sol
                    ( newnow > ( id(sun_sun).sunset(627)->timestamp - (id(nightonly).state*60) ) ) ||
                    // at√© minutos depois do nascer do sol
                    ( newnow < ( id(sun_sun).sunrise(627)->timestamp + (id(nightonly).state*60) ) )
                  );

        then:
          lambda: |-
            // is open
            if (x){
              id(my__counter) = id(maxseconds).state;
              id(relay).turn_on();

            // is cloused
            }else{
              int increase = abs(
                id(between_onoff_add).state *

                // increase seconds to OFF state
                (id(my__increase_off_counter) > 1 ? id(my__increase_off_counter) - 1 : 0 )
              );

              int max_addseconds  = abs( ((1.0+((float)id(between_onoff_maxadd).state))) * ((float)id(minseconds).state) );

              ESP_LOGI("main", "Contador incremental limitado a '%d' segundo(s).", max_addseconds);

              id(my__counter) = id(minseconds).state + increase;

              if (id(my__counter) > max_addseconds){
                id(my__counter) = max_addseconds;
              }

              if (id(my__counter) > id(maxseconds).state){
                id(my__counter) = id(maxseconds).state;
              }

              ESP_LOGI("main", "Iniciando timer em '%d' segundos.", id(my__counter));
            }

binary_sensor:
  - platform: gpio
    pin:
      number: ${pin_sensor}
      mode:
        input: true
        pulldown: true
    name: "1A. ${title_dooropened}"
    id: door
    filters:
      - delayed_on_off: 200ms
    on_state:
      - lambda: id(status_change)->execute(x);

  - platform: gpio
    pin:
      number: ${pin_button}
      mode:
        input: true
        pullup: true
    name: "Push Buttom"
    filters:
      - delayed_on_off: 200ms
    on_state:
      lambda: |-
        if (!x){
          id(relay).toggle();
        }

text_sensor:
  - platform: sun
    name: "4D. ${title_sunset_time}"
    id: "sunset_time"
    type: sunset
    format: "%H:%M"

  - platform: sun
    name: "4E. ${title_sunrise_time}"
    id: "sunrise_time"
    type: sunrise
    format: "%H:%M"

  - platform: template
    id: remainingtime
    icon: "mdi:icon7-clock-fill"
    name: "1C. ${title_off_in}"
  #    update_interval: 1s

  - platform: template
    id: again_on_counter
    name: "1E. ${title_again_on_counter}"
    icon: "mdi:icon7-calculator"
  #    update_interval: 60s

  - platform: template
    name: "9X. Date and Time"
    id: show_time
    lambda: |-
      ESPTime nowtime = id(ha_time).now();

      if (!nowtime.is_valid()){
        nowtime = id(sntp_time).now();
      }

      if (!nowtime.is_valid()){
        return {"..."};
      }

      char str[26];
      struct tm now = nowtime.to_c_tm();
      strftime(str, sizeof(str), "%H:%M, %d/%m/%Y", &now);
      return  { str };

  - platform: template
    name: "9Z. Github"
    icon: "mdi:icon-github"
    id: github
    lambda: return {"JeanCarloEM/esphome_timed_door_light"};
    update_interval: 3600s

  - platform: version
    name: "9Y. ESPHome Version"
